name: Update Customer IP Ranges

on:
  schedule:
    # Run every day at 2am UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      include_needle:
        description: Include needle scenario (tighten internal CIDR + open PR)
        type: boolean
        required: false
        default: false

concurrency:
  group: signals-demo
  cancel-in-progress: false

jobs:
  modify:
    name: Modify main.tf (routine or needle)
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          ref: main

      - name: Configure Git
        run: |
          # Use a neutral automation identity that matches what you'd typically see in real repos.
          git config user.name "Platform Automation"
          git config user.email "platform-automation@company.com"

      - name: Modify customer IP ranges
        run: |
          # Routine allowlist maintenance:
          # - Never narrow or shift customer CIDRs (avoid breaking existing clients).
          # - Broaden exactly one customer CIDR per run (small, innocuous change), rotating.
          # - Once all customers are at a cap, add a new customer (routine onboarding churn).
          python3 - <<'PY'
          import ipaddress
          import re
          import sys

          path = "main.tf"
          content = open(path, "r").read()

          customers = ["acme_corp", "globex", "initech", "umbrella", "cyberdyne"]
          max_broaden_prefix = {
              # /32: broaden to /31 then /30, then stop
              "acme_corp": 30,
              "initech": 30,
              # /29: broaden to /28, then stop
              "globex": 28,
              "cyberdyne": 28,
              # /24: treat as already capped (keeps it plausible)
              "umbrella": 24,
          }

          def get_customer_cidr(key: str, text: str) -> str:
              m = re.search(rf"{re.escape(key)}\\s*=\\s*\\{{[^}}]*?\\bcidr\\s*=\\s*\"([^\"]+)\"", text, re.S)
              if not m:
                  raise RuntimeError(f\"Could not find cidr for customer '{key}'\")
              return m.group(1)

          def set_customer_cidr(key: str, new_cidr: str, text: str) -> str:
              return re.sub(
                  rf\"({re.escape(key)}\\s*=\\s*\\{{[^}}]*?\\bcidr\\s*=\\s*\\\")([^\"]+)(\\\")\",
                  rf\"\\g<1>{new_cidr}\\g<3>\",
                  text,
                  flags=re.S,
                  count=1,
              )

          def broaden_one_step(cidr: str, cap_prefix: int) -> str:
              net = ipaddress.ip_network(cidr, strict=True)
              # smaller prefixlen == broader network; don't go broader than cap
              if net.prefixlen <= cap_prefix:
                  return cidr
              new_prefix = max(net.prefixlen - 1, cap_prefix)
              return str(net.supernet(new_prefix=new_prefix))

          updated = content

          broadened_key = None
          current = None
          new = None
          for key in customers:
              current = get_customer_cidr(key, updated)
              cap = max_broaden_prefix[key]
              new = broaden_one_step(current, cap)
              if new != current:
                  updated = set_customer_cidr(key, new, updated)
                  broadened_key = key
                  break

          if broadened_key is not None:
              open(path, "w").write(updated)
              print(f\"Routine change: broadened {broadened_key} ({current} -> {new}).\")
              sys.exit(0)

          # No customer can be broadened: add a new customer (routine onboarding).
          existing = [int(m.group(1)) for m in re.finditer(r\"\\bnewco_(\\d+)\\b\", updated)]
          n = (max(existing) if existing else 0) + 1
          new_key = f\"newco_{n}\"
          new_name = f\"NewCo {n}\"
          new_cidr = f\"203.0.113.{100 + n}/32\"

          # Insert into api_customer_cidrs map immediately after its opening line.
          if \"api_customer_cidrs = {\" not in updated:
              raise RuntimeError(\"Could not find api_customer_cidrs map\")
          updated = updated.replace(
              \"api_customer_cidrs = {\",
              \"api_customer_cidrs = {\\n\" +
              f\"    {new_key} = {{\\n\" +
              f\"      cidr = \\\"{new_cidr}\\\"\\n\" +
              f\"      name = \\\"{new_name}\\\"\\n\" +
              f\"    }}\\n\",
              1,
          )

          open(path, \"w\").write(updated)
          print(f\"Routine change: added customer {new_key} ({new_cidr}).\")
          PY

      - name: Needle scenario - tighten internal CIDR
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.include_needle == 'true' }}
        run: |
          python3 .github/scripts/update-internal-cidr.py main.tf "10.0.0.0/16" "SECURITY HARDENING: Narrowed to VPC CIDR per audit findings"

      - name: Show changes
        run: |
          echo "## Changes to main.tf" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```diff' >> $GITHUB_STEP_SUMMARY
          git diff main.tf >> $GITHUB_STEP_SUMMARY || echo "No changes detected"
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          # Also print to console
          echo "=== Git diff ==="
          git diff main.tf || echo "No changes detected"

      - name: Upload artifact (modified main.tf)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: signals-demo-main-tf
          if-no-files-found: error
          path: |
            main.tf

  plan-and-apply:
    name: Terraform plan/apply (routine only)
    runs-on: ubuntu-latest
    needs: modify
    if: >-
      ${{
        needs.modify.result == 'success' &&
        (
          github.event_name == 'schedule' ||
          (github.event_name == 'workflow_dispatch' && github.event.inputs.include_needle != 'true')
        )
      }}
    permissions:
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          ref: main

      - name: Download modified main.tf
        uses: actions/download-artifact@v4
        with:
          name: signals-demo-main-tf
          path: ./artifacts

      - name: Restore modified main.tf
        run: |
          cp ./artifacts/main.tf ./main.tf

      - name: Terraform Init
        uses: ./.github/actions/terraform_init/
        with:
          terraform_deploy_role: ${{ vars.TERRAFORM_DEPLOY_ROLE }}
          terraform_workspace: terraform-example

      - name: Terraform Plan
        run: terraform plan -out=tfplan

      - name: Convert plan to JSON
        run: terraform show -json tfplan > tfplan.json

      - uses: overmindtech/actions/install-cli@main
        with:
          version: latest
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - uses: overmindtech/actions/submit-plan@main
        id: submit-plan
        with:
          ovm-api-key: ${{ secrets.OVM_API_KEY }}
          plan-json: tfplan.json
          tags: 'model=risks_v6'

      - uses: overmindtech/actions/start-change@main
        with:
          ovm-api-key: ${{ secrets.OVM_API_KEY }}

      - name: Terraform Apply
        id: terraform-apply
        run: terraform apply -auto-approve tfplan

      - uses: overmindtech/actions/end-change@main
        if: steps.terraform-apply.outcome == 'success'
        with:
          ovm-api-key: ${{ secrets.OVM_API_KEY }}

      - name: Upload plan artifacts (optional)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: signals-demo-tfplan
          if-no-files-found: ignore
          path: |
            tfplan
            tfplan.json

  commit-routine:
    name: Commit routine changes directly to main
    runs-on: ubuntu-latest
    needs: plan-and-apply
    if: >-
      ${{
        needs.plan-and-apply.result == 'success' &&
        (
          github.event_name == 'schedule' ||
          (github.event_name == 'workflow_dispatch' && github.event.inputs.include_needle != 'true')
        )
      }}
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          ref: main

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Configure Git
        run: |
          git config user.name "Platform Automation"
          git config user.email "platform-automation@company.com"

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: signals-demo-main-tf
          path: ./artifacts

      - name: Restore modified main.tf
        run: |
          cp ./artifacts/main.tf ./main.tf

      - name: Terraform fmt
        run: terraform fmt -no-color main.tf

      - name: Commit and push
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          git add main.tf
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: update customer IP ranges"
            git push origin main
          fi

  create-pr:
    name: Create PR for security hardening change
    runs-on: ubuntu-latest
    needs: modify
    if: >-
      ${{
        needs.modify.result == 'success' &&
        github.event_name == 'workflow_dispatch' &&
        github.event.inputs.include_needle == 'true'
      }}
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          ref: main

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Configure Git
        run: |
          git config user.name "Platform Automation"
          git config user.email "platform-automation@company.com"

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: signals-demo-main-tf
          path: ./artifacts

      - name: Restore modified main.tf
        run: |
          cp ./artifacts/main.tf ./main.tf

      - name: Terraform fmt
        run: terraform fmt -no-color main.tf

      - name: Create branch, commit, and push
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          # Use a realistic branch naming convention (team/topic + ticket).
          BRANCH="security/jira-4521-narrow-internal-cidr-$(date +%Y%m%d-%H%M%S)"
          echo "BRANCH=$BRANCH" >> "$GITHUB_ENV"

          git checkout -b "$BRANCH"
          git add main.tf

          if git diff --staged --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          git commit -m "security: narrow internal ingress CIDR (JIRA-4521)"
          git push -u origin "$BRANCH"

      - name: Open pull request
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          BODY="$(printf '%s\n' \
            '## Summary' \
            '- Narrow internal ingress CIDR used for service/monitoring access.' \
            '' \
            '## Context' \
            '- JIRA-4521: Reduce internal exposure based on audit feedback.' \
            '' \
            '## Testing' \
            '- Terraform plan reviewed in CI.' \
            '' \
            '## Rollout / Risk' \
            '- If any internal tooling relies on the broader range, it may lose access; monitor health checks and alarms after merge.' \
          )"

          gh pr create \
            --base main \
            --head "$BRANCH" \
            --title "security: narrow internal ingress CIDR (JIRA-4521)" \
            --body "$BODY"
